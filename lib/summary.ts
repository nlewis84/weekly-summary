/**
 * Weekly Summary - Core logic
 * Fetches Linear + GitHub data, parses check-ins, builds payload with stats.
 * Reference: Apollos/weekly-summary.js (logic only, no file copying)
 */

import { mkdirSync, existsSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import type { Payload, RunSummaryResult, CheckIn, Stats } from "./types.js";
import { buildMarkdownSummary } from "./markdown.js";

const SUMMARY_README = `# Weekly Work Summaries

Generated by weekly-summary. Each file is named by week-ending date (YYYY-MM-DD).
`;

const LINEAR_API_BASE = "https://api.linear.app/graphql";
const GITHUB_API_BASE = "https://api.github.com";

const LINEAR_USER_QUERY = `
  query GetViewer {
    viewer { id name email }
  }
`;

const LINEAR_COMPLETED_QUERY = `
  query GetCompletedIssues($assigneeId: ID, $completedAfter: DateTimeOrDuration!, $completedBefore: DateTimeOrDuration!, $after: String) {
    issues(filter: { assignee: { id: { eq: $assigneeId } }, completedAt: { gte: $completedAfter, lte: $completedBefore } }, first: 100, after: $after) {
      nodes { id identifier title state { name type } url completedAt project { name } }
      pageInfo { hasNextPage endCursor }
    }
  }
`;

const LINEAR_WORKED_ON_QUERY = `
  query GetWorkedOnIssues($assigneeId: ID, $updatedAfter: DateTimeOrDuration!, $after: String) {
    issues(filter: { assignee: { id: { eq: $assigneeId } }, updatedAt: { gte: $updatedAfter } }, first: 100, after: $after) {
      nodes { id identifier title state { name type } url completedAt project { name } }
      pageInfo { hasNextPage endCursor }
    }
  }
`;

export function getWindowStart(now: Date, todayMode: boolean, yesterdayMode = false): Date {
  if (yesterdayMode) {
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    return new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 0, 0, 0, 0);
  }
  if (todayMode) {
    return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  }
  const day = now.getDay();
  const daysSinceSaturday = (day + 1) % 7;
  const saturday = new Date(now);
  saturday.setDate(now.getDate() - daysSinceSaturday);
  saturday.setHours(0, 0, 0, 0);
  return saturday;
}

export function getWindowEnd(now: Date, todayMode = false, yesterdayMode = false): Date {
  if (yesterdayMode) {
    const yesterday = new Date(now);
    yesterday.setDate(now.getDate() - 1);
    return new Date(
      yesterday.getFullYear(),
      yesterday.getMonth(),
      yesterday.getDate(),
      23,
      59,
      59,
      999
    );
  }
  return new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate(),
    23,
    59,
    59,
    999
  );
}

export function parseCheckIns(checkInsText: string): CheckIn[] {
  if (!checkInsText?.trim()) return [];

  const skipPatterns = [
    /^Apollos Engineering:/i,
    /^Nathan Lewis/i,
    /^File‚Ä¶/,
    /^PR Reviews?$/i,
    /^> /,
  ];

  const isSkipLine = (line: string) => {
    const t = line.trim();
    if (!t) return true;
    return skipPatterns.some((p) => p.test(t));
  };

  const lines = checkInsText.split("\n");
  const entries: CheckIn[] = [];
  let currentDay: string | null = null;
  let currentContent: string[] = [];

  const dayRegex =
    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday|Yesterday|Dec \d+|December \d+)[:.]?\s*(.*)$/i;

  for (const line of lines) {
    if (isSkipLine(line)) continue;

    const m = line.match(dayRegex);
    if (m) {
      if (currentDay && currentContent.length > 0) {
        const content = currentContent.join("\n").trim();
        if (content) entries.push({ day: currentDay, content });
      }
      currentDay = m[1];
      currentContent = m[2]?.trim() ? [m[2].trim()] : [];
    } else if (currentDay && !isSkipLine(line)) {
      currentContent.push(line);
    }
  }

  if (currentDay && currentContent.length > 0) {
    const content = currentContent.join("\n").trim();
    if (content) entries.push({ day: currentDay, content });
  }

  return entries.length > 0 ? entries : [{ day: "Check-ins", content: checkInsText.trim() }];
}

async function fetchLinearPage(
  headers: Record<string, string>,
  query: string,
  variables: Record<string, unknown>
) {
  const res = await fetch(LINEAR_API_BASE, {
    method: "POST",
    headers,
    body: JSON.stringify({ query, variables }),
  });
  if (!res.ok) throw new Error(`Linear API: ${res.status}`);
  const data = await res.json();
  if (data.errors) throw new Error(`Linear: ${JSON.stringify(data.errors)}`);
  return data.data;
}

async function fetchAllLinearIssues(
  headers: Record<string, string>,
  query: string,
  variables: Record<string, unknown>
) {
  const all: unknown[] = [];
  let after: string | null = null;
  const base = { ...variables };
  do {
    const vars = { ...base, after };
    const data = await fetchLinearPage(headers, query, vars);
    const conn = (data as { issues?: { nodes: unknown[]; pageInfo?: { hasNextPage?: boolean; endCursor?: string } } })?.issues;
    if (!conn?.nodes) break;
    all.push(...conn.nodes);
    if (!conn.pageInfo?.hasNextPage) break;
    after = conn.pageInfo?.endCursor ?? null;
  } while (after !== null);
  return all as Array<{ state?: { name?: string; type?: string }; completedAt?: string | null }>;
}

async function fetchLinearData(
  windowStart: Date,
  windowEnd: Date,
  windowStartISO: string,
  windowEndISO: string
) {
  const key = process.env.LINEAR_API_KEY;
  if (!key) return { completedIssues: [], workedOnIssues: [], userName: null };

  const headers = { Authorization: key, "Content-Type": "application/json" };

  try {
    const userData = await fetchLinearPage(headers, LINEAR_USER_QUERY, {});
    const userId = (userData as { viewer?: { id?: string; name?: string } })?.viewer?.id;
    if (!userId) throw new Error("No Linear user ID");

    const userName = (userData as { viewer?: { name?: string } })?.viewer?.name ?? null;

    const completedIssues = await fetchAllLinearIssues(headers, LINEAR_COMPLETED_QUERY, {
      assigneeId: userId,
      completedAfter: windowStartISO,
      completedBefore: windowEndISO,
    });

    const rawWorkedOn = await fetchAllLinearIssues(headers, LINEAR_WORKED_ON_QUERY, {
      assigneeId: userId,
      updatedAfter: windowStartISO,
    });

    const workedOnIssues = rawWorkedOn.filter((issue) => {
      const stateName = issue.state?.name ?? "";
      const stateType = issue.state?.type ?? "";
      const completedAt = issue.completedAt ? new Date(issue.completedAt) : null;
      if (stateName === "In Progress" || stateName === "In Review") return true;
      if (stateName === "Done" || stateType === "completed") {
        if (!completedAt) return false;
        return completedAt >= windowStart && completedAt <= windowEnd;
      }
      return false;
    });

    return { completedIssues, workedOnIssues, userName };
  } catch {
    return { completedIssues: [], workedOnIssues: [], userName: null };
  }
}

function filterApollosPRs(items: Array<{ html_url?: string }>) {
  return (items ?? []).filter((pr) => pr.html_url?.includes("ApollosProject"));
}

async function fetchCommitsPushed(
  username: string,
  headers: Record<string, string>,
  windowStart: Date,
  windowEnd: Date
): Promise<number> {
  try {
    const res = await fetch(`${GITHUB_API_BASE}/users/${username}/events?per_page=100`, { headers });
    if (!res.ok) return 0;
    const events = (await res.json()) as Array<{
      type?: string;
      created_at?: string;
      payload?: { commits?: unknown[] };
    }>;
    let total = 0;
    for (const ev of events) {
      if (ev.type !== "PushEvent") continue;
      const createdAt = ev.created_at ? new Date(ev.created_at) : null;
      if (!createdAt || createdAt < windowStart || createdAt > windowEnd) continue;
      total += (ev.payload?.commits ?? []).length;
    }
    return total;
  } catch {
    return 0;
  }
}

async function fetchGitHubData(
  windowStart: Date,
  windowStartISO: string,
  windowEnd: Date
) {
  const token = process.env.GITHUB_TOKEN;
  const username = process.env.GITHUB_USERNAME ?? "nlewis84";
  if (!token) return { prs: [], reviews: [], comments: 0, commits_pushed: 0 };

  const headers = {
    Authorization: `Bearer ${token}`,
    Accept: "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
  };
  const since = windowStartISO.split("T")[0];

  try {
    const [prsCreatedRes, prsUpdatedRes, reviewsRes, commitsPushed] = await Promise.all([
      fetch(
        `${GITHUB_API_BASE}/search/issues?q=author:${username}+type:pr+created:>=${since}&per_page=100`,
        { headers }
      ),
      fetch(
        `${GITHUB_API_BASE}/search/issues?q=author:${username}+type:pr+updated:>=${since}&per_page=100`,
        { headers }
      ),
      fetch(
        `${GITHUB_API_BASE}/search/issues?q=reviewed-by:${username}+type:pr+updated:>=${since}&per_page=100`,
        { headers }
      ),
      fetchCommitsPushed(username, headers, windowStart, windowEnd),
    ]);

    const [prsCreatedData, prsUpdatedData, reviewsData] = await Promise.all([
      prsCreatedRes.ok ? prsCreatedRes.json() : { items: [] },
      prsUpdatedRes.ok ? prsUpdatedRes.json() : { items: [] },
      reviewsRes.ok ? reviewsRes.json() : { items: [] },
    ]);

    const allPRs = [...(prsCreatedData.items ?? []), ...(prsUpdatedData.items ?? [])];
    const seen = new Set<string>();
    const uniquePRs = allPRs.filter((pr: { html_url?: string }) => {
      if (!pr.html_url || seen.has(pr.html_url)) return false;
      seen.add(pr.html_url);
      return pr.html_url.includes("ApollosProject");
    });

    const prDetails = await Promise.all(
      uniquePRs.map(async (pr: { pull_request?: { url?: string }; html_url?: string; merged_at?: string; state?: string }) => {
        if (pr.pull_request?.url) {
          try {
            const r = await fetch(pr.pull_request.url, { headers });
            if (r.ok) {
              const d = await r.json();
              return { ...pr, merged_at: d.merged_at, state: d.state };
            }
          } catch {
            /* fetch failed, use original pr */
          }
        }
        return pr;
      })
    );

    const reviews = filterApollosPRs(reviewsData.items ?? []);

    const allForComments = [...prDetails, ...reviews].slice(0, 20) as Array<{
      comments_url?: string;
      created_at?: string;
    }>;
    const commentCounts = await Promise.all(
      allForComments.map(async (pr) => {
        try {
          if (!pr.comments_url) return 0;
          const r = await fetch(pr.comments_url, { headers });
          if (!r.ok) return 0;
          const comments = await r.json();
          return comments.filter(
            (c: { user?: { login?: string }; created_at?: string }) =>
              c.user?.login === username &&
              c.created_at != null &&
              new Date(c.created_at) >= windowStart
          ).length;
        } catch {
          return 0;
        }
      })
    );
    const totalComments = commentCounts.reduce((a, b) => a + b, 0);

    return { prs: prDetails, reviews, comments: totalComments, commits_pushed: commitsPushed };
  } catch {
    return { prs: [], reviews: [], comments: 0, commits_pushed: 0 };
  }
}

function categorizePRs(
  prs: Array<{ merged_at?: string | null; state?: string }>,
  windowStart: Date
) {
  const merged = prs.filter((pr) => pr.merged_at && new Date(pr.merged_at) >= windowStart);
  const open = prs.filter((pr) => pr.state === "open" && !pr.merged_at);
  return { merged, open };
}

function groupPRsByRepo(prs: Array<{ html_url?: string }>) {
  const grouped: Record<string, unknown[]> = {};
  for (const pr of prs) {
    const m = pr.html_url?.match(/ApollosProject\/([^/]+)/);
    const repo = m ? m[1] : "unknown";
    if (!grouped[repo]) grouped[repo] = [];
    grouped[repo].push(pr);
  }
  return grouped;
}

function buildTerminalOutput(
  linearData: { completedIssues: unknown[]; workedOnIssues: unknown[] },
  githubData: { prs: unknown[]; reviews: unknown[]; commits_pushed?: number },
  checkIns: CheckIn[],
  prCategories: { merged: unknown[] },
  repos: string[]
): string {
  let out = "\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n";
  out += "‚ïë     Weekly Work Summary                                  ‚ïë\n";
  out += "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n";

  out += "üìä Stats:\n\n";
  out += `  ‚Ä¢ PRs merged: ${prCategories.merged.length}\n`;
  out += `  ‚Ä¢ PR reviews: ${githubData.reviews.length}\n`;
  out += `  ‚Ä¢ Commits pushed: ${githubData.commits_pushed ?? 0}\n`;
  out += `  ‚Ä¢ Linear issues completed: ${linearData.completedIssues.length}\n`;
  out += `  ‚Ä¢ Linear issues worked on: ${linearData.workedOnIssues.length}\n`;
  out += `  ‚Ä¢ Repos: ${repos.join(", ") || "‚Äî"}\n\n`;

  if (checkIns.length > 0) {
    out += "üìù Check-ins:\n\n";
    for (const c of checkIns) {
      out += `  ${c.day}: ${c.content.slice(0, 80)}${c.content.length > 80 ? "..." : ""}\n`;
    }
  }

  return out;
}

export { buildMarkdownSummary } from "./markdown.js";

export function saveWeeklySummary(payload: Payload, outputDir: string): void {
  try {
    if (!existsSync(outputDir)) {
      mkdirSync(outputDir, { recursive: true });
      writeFileSync(join(outputDir, "README.md"), SUMMARY_README, "utf8");
    }
    const weekEnding = payload.meta.week_ending;
    const jsonPath = join(outputDir, `${weekEnding}.json`);
    const mdPath = join(outputDir, `${weekEnding}.md`);

    writeFileSync(jsonPath, JSON.stringify(payload, null, 2), "utf8");
    writeFileSync(mdPath, buildMarkdownSummary(payload), "utf8");

    console.log(`\nüìÅ Saved to ${outputDir}/ (${weekEnding}.json, ${weekEnding}.md)`);
  } catch (err) {
    console.error(`‚ö†Ô∏è  Could not save summary: ${(err as Error).message}`);
  }
}

export async function runSummary(options: {
  todayMode: boolean;
  yesterdayMode?: boolean;
  checkInsText: string;
  outputDir: string | null;
}): Promise<RunSummaryResult> {
  const { todayMode, yesterdayMode = false, checkInsText } = options;
  const now = new Date();
  const windowStart = getWindowStart(now, todayMode, yesterdayMode);
  const windowEnd = getWindowEnd(now, todayMode, yesterdayMode);
  const windowStartISO = windowStart.toISOString();
  const windowEndISO = windowEnd.toISOString();

  const [linearData, githubData] = await Promise.all([
    fetchLinearData(windowStart, windowEnd, windowStartISO, windowEndISO),
    fetchGitHubData(windowStart, windowStartISO, windowEnd),
  ]);

  const checkIns = parseCheckIns(checkInsText);
  const prCategories = categorizePRs(githubData.prs, windowStart);
  // Include both PRs (created/updated) and reviews for "repos worked on"
  const prsAndReviews = [...githubData.prs, ...githubData.reviews];
  const prsByRepo = groupPRsByRepo(prsAndReviews);
  const repos = [...new Set(Object.keys(prsByRepo))].sort();

  const stats: Stats = {
    prs_merged: prCategories.merged.length,
    prs_total: githubData.prs.length,
    pr_reviews: githubData.reviews.length,
    pr_comments: githubData.comments,
    commits_pushed: githubData.commits_pushed,
    linear_completed: linearData.completedIssues.length,
    linear_worked_on: linearData.workedOnIssues.length,
    repos,
  };

  const terminalOutput = buildTerminalOutput(
    linearData,
    githubData,
    checkIns,
    prCategories,
    repos
  );

  const payload: Payload = {
    meta: {
      generated_at: new Date().toISOString(),
      window_start: windowStartISO,
      window_end: windowEndISO,
      week_ending: windowEnd.toISOString().slice(0, 10),
      source_of_truth:
        "End-of-year review and career narrative. Document leadership, ownership, mentoring, cross-team work, and technical impact.",
    },
    stats,
    linear: {
      completed_issues: linearData.completedIssues.map((i: { identifier?: string; title?: string; project?: { name?: string }; url?: string; completedAt?: string | null; state?: { name?: string; type?: string } }) => ({
        identifier: i.identifier ?? "",
        title: i.title ?? "",
        project: i.project?.name ?? null,
        url: i.url ?? null,
        completedAt: i.completedAt ?? null,
        state: i.state?.name ?? i.state?.type ?? null,
      })),
      worked_on_issues: linearData.workedOnIssues.map((i: { identifier?: string; title?: string; project?: { name?: string }; url?: string; completedAt?: string | null; state?: { name?: string; type?: string } }) => ({
        identifier: i.identifier ?? "",
        title: i.title ?? "",
        project: i.project?.name ?? null,
        url: i.url ?? null,
        completedAt: i.completedAt ?? null,
        state: i.state?.name ?? i.state?.type ?? null,
      })),
    },
    github: {
      merged_prs: prCategories.merged.map((pr: { title?: string; html_url?: string; merged_at?: string | null }) => {
        const m = pr.html_url?.match(/ApollosProject\/([^/]+)/);
        return {
          title: pr.title ?? "",
          url: pr.html_url ?? "",
          repo: m ? m[1] : null,
          merged_at: pr.merged_at ?? null,
        };
      }),
      reviews: githubData.reviews.map((pr: { title?: string; html_url?: string }) => ({
        title: pr.title ?? "",
        url: pr.html_url ?? "",
      })),
    },
    check_ins: checkIns,
    terminal_output: terminalOutput,
    formatted_output: null,
  };

  return {
    payload,
    terminalOutput,
    formattedOutput: null,
  };
}
